<!DOCTYPE html>
<meta charset="utf-8">
<style>

text {
  font: 10px sans-serif;
}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

var diameter = 960,
    format = d3.format(",d"),
    color = d3.scale.category20c();

var bubble = d3.layout.pack()
    .sort(null)
    .size([diameter, diameter])
    .padding(1.5);

var svg = d3.select("body").append("svg")
    .attr("width", diameter)
    .attr("height", diameter)
    .attr("class", "bubble");

//
//d3.json("flare.json", function(error, root) {
/////////////////////////////////////////////////////////Data Acquisition//////////////// 
d3.csv("data/dispodetail.csv", function(error, rdata){
	// beat the data into shape.  the example uses data structured 
	// "name": name, "flare". "children": [ {"name": "analytics", "children": [ { "name": "cluster", "children: [ {"name": "Agcluster", "size": 3456"} <other children of cluster> ]

// filter the data by county and year
var county = "Escambia";
var year = "2013"
var fdata=[]
var rdata = rdata.filter(function(d){
		return d["County"]== county})
for(i=0;i<rdata.length;i++)
fdata[i] = {
	"division": rdata[i].DivisionOfCourt,
	"ctype": rdata[i].TypeOfCase,
	"dtype": rdata[i].TypeOfDisposition,
	"year": year,
	"size": rdata[i][year]
	}

var newData = { name :"root", children : [] },
    levels = ["ctype","division"];
// clever recursive tree traversal adapted from http://stackoverflow.com/questions/19317115/convert-flat-json-file-to-hierarchical-json-data-like-flare-json-d3-example-fil
// For each data row, loop through the expected levels traversing the output tree
fdata.forEach(function(d){
    // Keep this as a reference to the current level
    var depthCursor = newData.children;
    // Go down one level at a time
    levels.forEach(function( property, depth ){
        // Look to see if a branch has already been created
        var index;
        depthCursor.forEach(function(child,i){
            if ( d[property] == child.name ) index = i;
        });
        // Add a branch if it isn't there
        if ( isNaN(index) ) {
            depthCursor.push({ name : d[property], children : []});
            index = depthCursor.length - 1;
        }
        // Now reference the new child array as we go deeper into the tree
        depthCursor = depthCursor[index].children;
        // This is a leaf, so add the last element to the specified branch
        if ( depth === levels.length - 1 ) depthCursor.push({ name : d.dtype, size : d.size });
    });
});
/////////////////////////////////////////////////////////////#End Data Acquisition///////
root = newData 
  var node = svg.selectAll(".node")
      .data(bubble.nodes(classes(root))
      .filter(function(d) { return !d.children; }))
    .enter().append("g")
      .attr("class", "node")
      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

  node.append("title")
      .text(function(d) { return d.className + ": " + format(d.value); });

  node.append("circle")
      .attr("r", function(d) { return d.r; })
      .style("fill", function(d) { return color(d.packageName); });

  node.append("text")
      .attr("dy", ".3em")
      .style("text-anchor", "middle")
      .text(function(d) { return d.className.substring(0, d.r / 3); });
});

// Returns a flattened hierarchy containing all leaf nodes under the root.
function classes(root) {
  var classes = [];

  function recurse(name, node) {
    if (node.children) node.children.forEach(function(child) { recurse(node.name, child); });
    else classes.push({packageName: name, className: node.name, value: node.size});
  }

  recurse(null, root);
  return {children: classes};
}

d3.select(self.frameElement).style("height", diameter + "px");

</script>
